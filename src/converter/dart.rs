use super::core::{ProtoMessage, ProtoEnum};

pub fn generate_class(class_name: &str, message: &ProtoMessage) -> String {
    let mut result = String::new();
    
    // 文件头
    result.push_str(&format!(
        "//\n//  {}.dart\n//  Generated by xcutils\n//\n\n",
        class_name
    ));
    
    // 类定义
    result.push_str(&format!("class {} {{\n", class_name));
    
    // 属性定义
    for field in &message.fields {
        if let Some(comment) = &field.comment {
            result.push_str(&format!("  /// {}\n", comment));
        }
        
        let type_name = convert_type(&field.type_name, field.is_repeated);
        let field_name = super::core::to_camel_case(&field.original_name);
        result.push_str(&format!("  final {}? {};\n\n", type_name, field_name));
    }
    
    // 构造函数
    result.push_str(&format!("  {}({{\n", class_name));
    for field in &message.fields {
        let field_name = super::core::to_camel_case(&field.original_name);
        result.push_str(&format!("    this.{},\n", field_name));
    }
    result.push_str("  });\n\n");
    
    // fromJson方法
    result.push_str(&format!("  factory {}.fromJson(Map<String, dynamic> json) {{\n", class_name));
    result.push_str(&format!("    return {}(\n", class_name));
    for field in &message.fields {
        let field_name = super::core::to_camel_case(&field.original_name);
        let original_name = &field.original_name;
        let type_name = &field.type_name;
        
        if field.is_repeated {
            result.push_str(&format!("      {}: json['{}'] != null ? List<{}>.from(json['{}']).map((item) => {}).toList() : null,\n", 
                field_name, original_name, convert_base_type(type_name), original_name, 
                if is_basic_type(type_name) { "item".to_string() } else { format!("{}.fromJson(item)", type_name) }));
        } else {
            let conversion = get_json_conversion(type_name, &format!("json['{}']", original_name));
            result.push_str(&format!("      {}: {},\n", field_name, conversion));
        }
    }
    result.push_str("    );\n");
    result.push_str("  }\n\n");
    
    // toJson方法
    result.push_str("  Map<String, dynamic> toJson() {\n");
    result.push_str("    return {\n");
    for field in &message.fields {
        let field_name = super::core::to_camel_case(&field.original_name);
        let original_name = &field.original_name;
        let type_name = &field.type_name;
        
        if field.is_repeated {
            if is_basic_type(type_name) {
                result.push_str(&format!("      '{}': {},\n", original_name, field_name));
            } else {
                result.push_str(&format!("      '{}': {}?.map((item) => item.toJson()).toList(),\n", original_name, field_name));
            }
        } else {
            if is_basic_type(type_name) {
                result.push_str(&format!("      '{}': {},\n", original_name, field_name));
            } else {
                result.push_str(&format!("      '{}': {}?.toJson(),\n", original_name, field_name));
            }
        }
    }
    result.push_str("    };\n");
    result.push_str("  }\n");
    result.push_str("}\n");
    
    result
}

pub fn generate_enum(enum_name: &str, proto_enum: &ProtoEnum) -> String {
    let mut result = String::new();
    
    // 文件头
    result.push_str(&format!(
        "//\n//  {}.dart\n//  Generated by xcutils\n//\n\n",
        enum_name
    ));
    
    // 枚举定义
    result.push_str(&format!("enum {} {{\n", enum_name));
    
    // 枚举值
    for (index, value) in proto_enum.values.iter().enumerate() {
        if let Some(comment) = &value.comment {
            result.push_str(&format!("  /// {}\n", comment));
        }
        let comma = if index == proto_enum.values.len() - 1 { "" } else { "," };
        result.push_str(&format!("  {}{}\n", value.name, comma));
    }
    
    result.push_str("}\n\n");
    
    // Extension for value conversion
    result.push_str(&format!("extension {}Extension on {} {{\n", enum_name, enum_name));
    
    // get value method
    result.push_str("  int get value {\n");
    result.push_str("    switch (this) {\n");
    for value in &proto_enum.values {
        result.push_str(&format!("      case {}.{}: return {};\n", enum_name, value.name, value.value));
    }
    result.push_str("    }\n");
    result.push_str("  }\n\n");
    
    // fromValue static method
    result.push_str(&format!("  static {}? fromValue(int value) {{\n", enum_name));
    result.push_str("    switch (value) {\n");
    for value in &proto_enum.values {
        result.push_str(&format!("      case {}: return {}.{};\n", value.value, enum_name, value.name));
    }
    result.push_str("      default: return null;\n");
    result.push_str("    }\n");
    result.push_str("  }\n");
    result.push_str("}\n");
    
    result
}

fn convert_type(proto_type: &str, is_repeated: bool) -> String {
    let base_type = convert_base_type(proto_type);
    if is_repeated {
        format!("List<{}>", base_type)
    } else {
        base_type
    }
}

fn convert_base_type(proto_type: &str) -> String {
    match proto_type.to_lowercase().as_str() {
        "int32" | "int64" | "uint32" | "uint64" | "sint32" | "sint64" => "int".to_string(),
        "float" | "double" => "double".to_string(),
        "bool" => "bool".to_string(),
        "string" => "String".to_string(),
        _ => proto_type.to_string(), // 自定义类型
    }
}

fn is_basic_type(proto_type: &str) -> bool {
    matches!(proto_type.to_lowercase().as_str(), 
        "int32" | "int64" | "uint32" | "uint64" | "sint32" | "sint64" | 
        "float" | "double" | "bool" | "string")
}

fn get_json_conversion(proto_type: &str, json_access: &str) -> String {
    match proto_type.to_lowercase().as_str() {
        "int32" | "int64" | "uint32" | "uint64" | "sint32" | "sint64" => {
            format!("{} as int?", json_access)
        },
        "float" | "double" => {
            format!("{} as double?", json_access)
        },
        "bool" => {
            format!("{} as bool?", json_access)
        },
        "string" => {
            format!("{} as String?", json_access)
        },
        _ => {
            // 对于自定义类型，假设它们有fromJson方法
            format!("{} != null ? {}.fromJson({}) : null", json_access, proto_type, json_access)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::super::core::{ProtoMessage, ProtoEnum, ProtoField, ProtoEnumValue};

    #[test]
    fn test_generate_simple_class() {
        let message = ProtoMessage {
            fields: vec![
                ProtoField {
                    original_name: "user_id".to_string(),
                    type_name: "int64".to_string(),
                    is_repeated: false,
                    comment: Some("用户ID".to_string()),
                },
                ProtoField {
                    original_name: "username".to_string(),
                    type_name: "string".to_string(),
                    is_repeated: false,
                    comment: Some("用户名".to_string()),
                },
                ProtoField {
                    original_name: "is_active".to_string(),
                    type_name: "bool".to_string(),
                    is_repeated: false,
                    comment: None,
                },
            ],
        };

        let result = generate_class("User", &message);
        
        // 验证生成的代码包含预期内容
        assert!(result.contains("class User {"));
        assert!(result.contains("/// 用户ID"));
        assert!(result.contains("final int? userId;"));
        assert!(result.contains("/// 用户名"));
        assert!(result.contains("final String? username;"));
        assert!(result.contains("final bool? isActive;"));
        assert!(result.contains("factory User.fromJson(Map<String, dynamic> json)"));
        assert!(result.contains("Map<String, dynamic> toJson()"));
        assert!(result.contains("userId: json['user_id'] as int?"));
        assert!(result.contains("username: json['username'] as String?"));
        assert!(result.contains("isActive: json['is_active'] as bool?"));
        assert!(result.contains("'user_id': userId"));
        assert!(result.contains("'username': username"));
        assert!(result.contains("'is_active': isActive"));
        
        println!("Generated class:\n{}", result);
    }

    #[test]
    fn test_generate_class_with_repeated_fields() {
        let message = ProtoMessage {
            fields: vec![
                ProtoField {
                    original_name: "tags".to_string(),
                    type_name: "string".to_string(),
                    is_repeated: true,
                    comment: Some("标签列表".to_string()),
                },
                ProtoField {
                    original_name: "scores".to_string(),
                    type_name: "int32".to_string(),
                    is_repeated: true,
                    comment: None,
                },
            ],
        };

        let result = generate_class("TestClass", &message);
        
        assert!(result.contains("final List<String>? tags;"));
        assert!(result.contains("final List<int>? scores;"));
        assert!(result.contains("tags: json['tags'] != null ? List<String>.from(json['tags']).map((item) => item).toList() : null"));
        assert!(result.contains("scores: json['scores'] != null ? List<int>.from(json['scores']).map((item) => item).toList() : null"));
        
        println!("Generated class with repeated fields:\n{}", result);
    }

    #[test]
    fn test_generate_simple_enum() {
        let proto_enum = ProtoEnum {
            values: vec![
                ProtoEnumValue {
                    name: "UNKNOWN".to_string(),
                    value: 0,
                    comment: Some("未知状态".to_string()),
                },
                ProtoEnumValue {
                    name: "ACTIVE".to_string(),
                    value: 1,
                    comment: Some("活跃状态".to_string()),
                },
                ProtoEnumValue {
                    name: "INACTIVE".to_string(),
                    value: 2,
                    comment: None,
                },
            ],
        };

        let result = generate_enum("UserStatus", &proto_enum);
        
        // 验证生成的代码包含预期内容
        assert!(result.contains("enum UserStatus {"));
        assert!(result.contains("/// 未知状态"));
        assert!(result.contains("UNKNOWN,"));
        assert!(result.contains("/// 活跃状态"));
        assert!(result.contains("ACTIVE,"));
        assert!(result.contains("INACTIVE"));
        assert!(!result.contains("INACTIVE,")); // 最后一个不应该有逗号
        assert!(result.contains("extension UserStatusExtension on UserStatus"));
        assert!(result.contains("int get value"));
        assert!(result.contains("case UserStatus.UNKNOWN: return 0;"));
        assert!(result.contains("case UserStatus.ACTIVE: return 1;"));
        assert!(result.contains("case UserStatus.INACTIVE: return 2;"));
        assert!(result.contains("static UserStatus? fromValue(int value)"));
        assert!(result.contains("case 0: return UserStatus.UNKNOWN;"));
        assert!(result.contains("case 1: return UserStatus.ACTIVE;"));
        assert!(result.contains("case 2: return UserStatus.INACTIVE;"));
        
        println!("Generated enum:\n{}", result);
    }

    #[test]
    fn test_generate_class_with_custom_types() {
        let message = ProtoMessage {
            fields: vec![
                ProtoField {
                    original_name: "address".to_string(),
                    type_name: "Address".to_string(),
                    is_repeated: false,
                    comment: Some("地址信息".to_string()),
                },
                ProtoField {
                    original_name: "contacts".to_string(),
                    type_name: "Contact".to_string(),
                    is_repeated: true,
                    comment: Some("联系方式列表".to_string()),
                },
            ],
        };

        let result = generate_class("User", &message);
        
        assert!(result.contains("final Address? address;"));
        assert!(result.contains("final List<Contact>? contacts;"));
        assert!(result.contains("address: json['address'] != null ? Address.fromJson(json['address']) : null"));
        assert!(result.contains("contacts: json['contacts'] != null ? List<Contact>.from(json['contacts']).map((item) => Contact.fromJson(item)).toList() : null"));
        
        println!("Generated class with custom types:\n{}", result);
    }

    #[test]
    fn test_generate_empty_class() {
        let message = ProtoMessage {
            fields: vec![],
        };

        let result = generate_class("EmptyClass", &message);
        
        assert!(result.contains("class EmptyClass {"));
        assert!(result.contains("EmptyClass();"));
        assert!(result.contains("factory EmptyClass.fromJson"));
        assert!(result.contains("Map<String, dynamic> toJson()"));
        
        println!("Generated empty class:\n{}", result);
    }

    #[test]
    fn test_generate_empty_enum() {
        let proto_enum = ProtoEnum {
            values: vec![],
        };

        let result = generate_enum("EmptyEnum", &proto_enum);
        
        assert!(result.contains("enum EmptyEnum {"));
        assert!(result.contains("extension EmptyEnumExtension on EmptyEnum"));
        
        println!("Generated empty enum:\n{}", result);
    }
}
