use super::core::{ProtoEnum, ProtoMessage};

pub fn generate_class(class_name: &str, message: &ProtoMessage) -> String {
    let mut result = String::new();

    // 文件头
    result.push_str(&format!(
        "//\n//  {}.kt\n//  Generated by xcutils\n//\n\n",
        class_name
    ));

    // 导入语句
    result.push_str("import kotlinx.serialization.Serializable\n");
    result.push_str("import kotlinx.serialization.SerialName\n\n");

    // 类定义
    result.push_str("@Serializable\n");
    result.push_str(&format!("data class {} (\n", class_name));

    // 属性定义
    for field in &message.fields {
        if let Some(comment) = &field.comment {
            result.push_str(&format!("    /** {} */\n", comment));
        }

        let type_name = convert_type(&field.type_name, field.is_repeated);
        let field_name = super::core::to_camel_case(&field.original_name);
        result.push_str(&format!("    @SerialName(\"{}\")\n", field.original_name));
        result.push_str(&format!("    val {}: {},\n", field_name, type_name));
    }

    // 移除最后一个逗号
    if !message.fields.is_empty() {
        result.pop(); // 移除换行
        result.pop(); // 移除逗号
        result.push('\n');
    }

    result.push_str(")\n");

    result
}

pub fn generate_enum(enum_name: &str, proto_enum: &ProtoEnum) -> String {
    let mut result = String::new();

    // 文件头
    result.push_str(&format!(
        "//\n//  {}.kt\n//  Generated by xcutils\n//\n\n",
        enum_name
    ));

    // 导入语句
    result.push_str("import kotlinx.serialization.Serializable\n");
    result.push_str("import kotlinx.serialization.KSerializer\n");
    result.push_str("import kotlinx.serialization.descriptors.PrimitiveKind\n");
    result.push_str("import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor\n");
    result.push_str("import kotlinx.serialization.descriptors.SerialDescriptor\n");
    result.push_str("import kotlinx.serialization.encoding.Decoder\n");
    result.push_str("import kotlinx.serialization.encoding.Encoder\n\n");

    // 枚举定义
    result.push_str(&format!(
        "@Serializable(with = {}.Serializer::class)\n",
        enum_name
    ));
    result.push_str(&format!("enum class {} (val value: Int) {{\n", enum_name));

    // 枚举值
    for (index, value) in proto_enum.values.iter().enumerate() {
        if let Some(comment) = &value.comment {
            result.push_str(&format!("    /** {} */\n", comment));
        }

        // 最后一个枚举值不加逗号
        if index < proto_enum.values.len() - 1 {
            result.push_str(&format!("    {} ({}),\n", value.name, value.value));
        } else {
            result.push_str(&format!("    {} ({});\n", value.name, value.value));
        }
    }

    // fromValue方法
    result.push_str("\n    companion object {\n");
    result.push_str(&format!(
        "        fun fromValue(value: Int): {}? = values().find {{ it.value == value }}\n",
        enum_name
    ));
    result.push_str("    }\n");
    // 序列化器
    result.push_str(&format!(
        "\n    class Serializer : KSerializer<{}> {{\n",
        enum_name
    ));
    result.push_str(&format!("        override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor(\"{}\", PrimitiveKind.INT)\n", enum_name));
    result.push_str(&format!("\n        override fun serialize(encoder: Encoder, value: {}) ",enum_name));
    result.push_str("{\n");
    result.push_str("            encoder.encodeInt(value.value)\n");
    result.push_str("        }\n");
    result.push_str(&format!(
        "\n        override fun deserialize(decoder: Decoder): {} {{\n",
        enum_name
    ));
    result.push_str("            val value = decoder.decodeInt()\n");
    result.push_str(&format!(
        "            return fromValue(value) ?: {}.values().first()\n",
        enum_name
    ));
    result.push_str("        }\n");
    result.push_str("    }\n");

    result.push_str("}\n");

    result
}

fn convert_type(proto_type: &str, is_repeated: bool) -> String {
    let base_type = match proto_type.to_lowercase().as_str() {
        "int32" | "int64" | "uint32" | "uint64" | "sint32" | "sint64" | "fixed32" | "fixed64"
        | "sfixed32" | "sfixed64" => "Int",
        "float" | "double" => "Double",
        "bool" => "Boolean",
        "string" => "String",
        "bytes" => "ByteArray",
        _ => proto_type, // 自定义类型保持原样
    };

    if is_repeated {
        format!("List<{}>", base_type)
    } else {
        base_type.to_string()
    }
}
