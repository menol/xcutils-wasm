use super::core::{ProtoMessage, ProtoEnum, ProtoField, ProtoEnumValue};

pub fn generate_interface(interface_name: &str, message: &ProtoMessage) -> String {
    let mut result = String::new();
    
    // 文件头
    result.push_str(&format!(
        "//\n//  {}.ts\n//  Generated by xcutils\n//\n\n",
        interface_name
    ));
    
    // 接口定义
    result.push_str(&format!("export interface {} {{\n", interface_name));
    
    // 属性定义
    for field in &message.fields {
        if let Some(comment) = &field.comment {
            result.push_str(&format!("  /** {} */\n", comment));
        }
        
        let type_name = convert_type(&field.type_name, field.is_repeated);
        let field_name = &field.original_name;
        result.push_str(&format!("  {}?: {};\n", field_name, type_name));
    }
    
    result.push_str("}\n");
    
    result
}

pub fn generate_enum(enum_name: &str, proto_enum: &ProtoEnum) -> String {
    let mut result = String::new();
    
    // 文件头
    result.push_str(&format!(
        "//\n//  {}.ts\n//  Generated by xcutils\n//\n\n",
        enum_name
    ));
    
    // 枚举定义
    result.push_str(&format!("export enum {} {{\n", enum_name));
    
    // 枚举值
    for value in &proto_enum.values {
        if let Some(comment) = &value.comment {
            result.push_str(&format!("  /** {} */\n", comment));
        }
        result.push_str(&format!("  {} = {},\n", value.name, value.value));
    }
    
    result.push_str("}\n");
    
    result
}

fn convert_type(proto_type: &str, is_repeated: bool) -> String {
    let base_type = match proto_type.to_lowercase().as_str() {
        "int32" | "int64" | "uint32" | "uint64" | "sint32" | "sint64" | "fixed32" | "fixed64" | "sfixed32" | "sfixed64" => "number",
        "float" | "double" => "number",
        "bool" => "boolean",
        "string" => "string",
        _ => proto_type,
    };
    
    if is_repeated {
        format!("{}[]", base_type)
    } else {
        base_type.to_string()
    }
}